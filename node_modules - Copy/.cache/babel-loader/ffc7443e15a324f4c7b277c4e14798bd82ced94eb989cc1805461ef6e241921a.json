{"ast":null,"code":"export const mintNFT = `\n// REPLACE THIS WITH YOUR CONTRACT NAME + ADDRESS\nimport FlowHead from 0x32aa0fc0bbec8419\n\n// Do not change these\nimport NonFungibleToken from 0x631e88ae7f1d7c20\nimport MetadataViews from 0x631e88ae7f1d7c20\n\ntransaction(\n  recipient: Address,\n  name: String,\n  description: String,\n  thumbnail: String,\n) {\n  prepare(signer: AuthAccount) {\n    if signer.borrow<&FlowHead.Collection>(from: FlowHead.CollectionStoragePath) != nil {\n      return\n    }\n\n    // Create a new empty collection\n    let collection <- FlowHead.createEmptyCollection()\n\n    // save it to the account\n    signer.save(<-collection, to: FlowHead.CollectionStoragePath)\n\n    // create a public capability for the collection\n    signer.link<&{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}>(\n      FlowHead.CollectionPublicPath,\n      target: FlowHead.CollectionStoragePath\n    )\n  }\n\n\n  execute {\n    // Borrow the recipient's public NFT collection reference\n    let receiver = getAccount(recipient)\n      .getCapability(FlowHead.CollectionPublicPath)\n      .borrow<&{NonFungibleToken.CollectionPublic}>()\n      ?? panic(\"Could not get receiver reference to the NFT Collection\")\n\n    // Mint the NFT and deposit it to the recipient's collection\n    FlowHead.mintNFT(\n      recipient: receiver,\n      name: name,\n      description: description,\n      thumbnail: thumbnail,\n    )\n    \n    log(\"Minted an NFT and stored it into the collection\")\n  } \n}\n`;","map":{"version":3,"names":["mintNFT"],"sources":["C:/Users/gugan/flow-hackverse/src/cadence/transactions/mintNFT_tx.js"],"sourcesContent":["export const mintNFT = \r\n`\r\n// REPLACE THIS WITH YOUR CONTRACT NAME + ADDRESS\r\nimport FlowHead from 0x32aa0fc0bbec8419\r\n\r\n// Do not change these\r\nimport NonFungibleToken from 0x631e88ae7f1d7c20\r\nimport MetadataViews from 0x631e88ae7f1d7c20\r\n\r\ntransaction(\r\n  recipient: Address,\r\n  name: String,\r\n  description: String,\r\n  thumbnail: String,\r\n) {\r\n  prepare(signer: AuthAccount) {\r\n    if signer.borrow<&FlowHead.Collection>(from: FlowHead.CollectionStoragePath) != nil {\r\n      return\r\n    }\r\n\r\n    // Create a new empty collection\r\n    let collection <- FlowHead.createEmptyCollection()\r\n\r\n    // save it to the account\r\n    signer.save(<-collection, to: FlowHead.CollectionStoragePath)\r\n\r\n    // create a public capability for the collection\r\n    signer.link<&{NonFungibleToken.CollectionPublic, MetadataViews.ResolverCollection}>(\r\n      FlowHead.CollectionPublicPath,\r\n      target: FlowHead.CollectionStoragePath\r\n    )\r\n  }\r\n\r\n\r\n  execute {\r\n    // Borrow the recipient's public NFT collection reference\r\n    let receiver = getAccount(recipient)\r\n      .getCapability(FlowHead.CollectionPublicPath)\r\n      .borrow<&{NonFungibleToken.CollectionPublic}>()\r\n      ?? panic(\"Could not get receiver reference to the NFT Collection\")\r\n\r\n    // Mint the NFT and deposit it to the recipient's collection\r\n    FlowHead.mintNFT(\r\n      recipient: receiver,\r\n      name: name,\r\n      description: description,\r\n      thumbnail: thumbnail,\r\n    )\r\n    \r\n    log(\"Minted an NFT and stored it into the collection\")\r\n  } \r\n}\r\n`"],"mappings":"AAAA,OAAO,MAAMA,OAAO,GACnB;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}