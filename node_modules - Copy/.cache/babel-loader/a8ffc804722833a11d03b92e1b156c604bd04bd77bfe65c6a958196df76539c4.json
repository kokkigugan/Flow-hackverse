{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport _createForOfIteratorHelper from '@babel/runtime/helpers/createForOfIteratorHelper';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _typeof from '@babel/runtime/helpers/typeof';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport queueMicrotask from 'queue-microtask';\nvar mailbox = function mailbox() {\n  var queue = [];\n  var next;\n  return {\n    deliver: function deliver(msg) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                queue.push(msg);\n                if (next) {\n                  next(queue.shift());\n                  next = undefined;\n                }\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n    receive: function receive() {\n      return new Promise(function innerReceive(resolve) {\n        var msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\nvar INIT = \"INIT\";\nvar SUBSCRIBE = \"SUBSCRIBE\";\nvar UNSUBSCRIBE = \"UNSUBSCRIBE\";\nvar UPDATED = \"UPDATED\";\nvar SNAPSHOT = \"SNAPSHOT\";\nvar EXIT = \"EXIT\";\nvar TERMINATE = \"TERMINATE\";\nvar root = (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === \"object\" && self.self === self && self || (typeof global === \"undefined\" ? \"undefined\" : _typeof(global)) === \"object\" && global.global === global && global || (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && window.window === window && window;\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nvar pid = 0;\nvar DEFAULT_TIMEOUT = 5000;\nvar _send = function send(addr, tag, data) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Promise(function (reply, reject) {\n    var expectReply = opts.expectReply || false;\n    var timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(function () {\n        return reject(new Error(\"Timeout: \".concat(timeout, \"ms passed without a response.\")));\n      }, timeout);\n    }\n    var payload = {\n      to: addr,\n      from: opts.from,\n      tag: tag,\n      data: data,\n      timeout: timeout,\n      reply: reply,\n      reject: reject\n    };\n    try {\n      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);\n      if (!expectReply) reply(true);\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, root.FCL_REGISTRY[addr], error);\n    }\n  });\n};\nvar kill = function kill(addr) {\n  delete root.FCL_REGISTRY[addr];\n};\nvar fromHandlers = function fromHandlers() {\n  var handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ctx) {\n      var letter;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof handlers[INIT] === \"function\")) {\n                _context.next = 3;\n                break;\n              }\n              _context.next = 3;\n              return handlers[INIT](ctx);\n            case 3:\n              _context.next = 6;\n              return ctx.receive();\n            case 6:\n              letter = _context.sent;\n              _context.prev = 7;\n              if (!(letter.tag === EXIT)) {\n                _context.next = 13;\n                break;\n              }\n              if (!(typeof handlers[TERMINATE] === \"function\")) {\n                _context.next = 12;\n                break;\n              }\n              _context.next = 12;\n              return handlers[TERMINATE](ctx, letter, letter.data || {});\n            case 12:\n              return _context.abrupt(\"break\", 25);\n            case 13:\n              _context.next = 15;\n              return handlers[letter.tag](ctx, letter, letter.data || {});\n            case 15:\n              _context.next = 20;\n              break;\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context[\"catch\"](7);\n              console.error(\"\".concat(ctx.self(), \" Error\"), letter, _context.t0);\n            case 20:\n              _context.prev = 20;\n              return _context.abrupt(\"continue\", 3);\n            case 23:\n              _context.next = 3;\n              break;\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[7, 17, 20, 23]]);\n    }));\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\nvar spawn = function spawn(fn) {\n  var addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (addr == null) addr = ++pid;\n  if (root.FCL_REGISTRY[addr] != null) return addr;\n  root.FCL_REGISTRY[addr] = {\n    addr: addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  var ctx = {\n    self: function self() {\n      return addr;\n    },\n    receive: function receive() {\n      return root.FCL_REGISTRY[addr].mailbox.receive();\n    },\n    send: function send(to, tag, data) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      opts.from = addr;\n      return _send(to, tag, data, opts);\n    },\n    sendSelf: function sendSelf(tag, data, opts) {\n      if (root.FCL_REGISTRY[addr]) _send(addr, tag, data, opts);\n    },\n    broadcast: function broadcast(tag, data) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.from = addr;\n      var _iterator = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var to = _step.value;\n          _send(to, tag, data, opts);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    },\n    subscribe: function subscribe(sub) {\n      return sub != null && root.FCL_REGISTRY[addr].subs.add(sub);\n    },\n    unsubscribe: function unsubscribe(sub) {\n      return sub != null && root.FCL_REGISTRY[addr].subs[\"delete\"](sub);\n    },\n    subscriberCount: function subscriberCount() {\n      return root.FCL_REGISTRY[addr].subs.size;\n    },\n    hasSubs: function hasSubs() {\n      return !!root.FCL_REGISTRY[addr].subs.size;\n    },\n    put: function put(key, value) {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;\n    },\n    get: function get(key, fallback) {\n      var value = root.FCL_REGISTRY[addr].kvs[key];\n      return value == null ? fallback : value;\n    },\n    \"delete\": function _delete(key) {\n      delete root.FCL_REGISTRY[addr].kvs[key];\n    },\n    update: function update(key, fn) {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);\n    },\n    keys: function keys() {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs);\n    },\n    all: function all() {\n      return root.FCL_REGISTRY[addr].kvs;\n    },\n    where: function where(pattern) {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce(function (acc, key) {\n        return pattern.test(key) ? _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, root.FCL_REGISTRY[addr].kvs[key])) : acc;\n      }, {});\n    },\n    merge: function merge() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(data).forEach(function (key) {\n        return root.FCL_REGISTRY[addr].kvs[key] = data[key];\n      });\n    },\n    fatalError: function fatalError(error) {\n      root.FCL_REGISTRY[addr].error = error;\n      var _iterator2 = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var to = _step2.value;\n          _send(to, UPDATED);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  };\n  if (_typeof(fn) === \"object\") fn = fromHandlers(fn);\n  queueMicrotask( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return fn(ctx);\n          case 2:\n            kill(addr);\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  })));\n  return addr;\n}; // Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\n\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  var EXIT = \"@EXIT\";\n  var self = spawn( /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(ctx) {\n      var letter, error;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              ctx.send(address, SUBSCRIBE);\n            case 1:\n              _context3.next = 4;\n              return ctx.receive();\n            case 4:\n              letter = _context3.sent;\n              error = root.FCL_REGISTRY[address].error;\n              if (!(letter.tag === EXIT)) {\n                _context3.next = 9;\n                break;\n              }\n              ctx.send(address, UNSUBSCRIBE);\n              return _context3.abrupt(\"return\");\n            case 9:\n              if (!error) {\n                _context3.next = 13;\n                break;\n              }\n              callback(null, error);\n              ctx.send(address, UNSUBSCRIBE);\n              return _context3.abrupt(\"return\");\n            case 13:\n              callback(letter.data, null);\n              _context3.next = 1;\n              break;\n            case 16:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return function (_x2) {\n      return _ref3.apply(this, arguments);\n    };\n  }());\n  return function () {\n    return _send(self, EXIT);\n  };\n} // Returns a promise that returns a result\n// A SNAPSHOT handler will need to be created to handle the snapshot event\n//\n//  [SNAPSHOT]: (ctx, letter) => {\n//    letter.reply(ctx.all())\n//  }\n//\n\nfunction snapshoter(address, spawnFn) {\n  spawnFn(address);\n  return _send(address, SNAPSHOT, null, {\n    expectReply: true,\n    timeout: 0\n  });\n}\nexport { EXIT, INIT, SNAPSHOT, SUBSCRIBE, TERMINATE, UNSUBSCRIBE, UPDATED, kill, _send as send, snapshoter, spawn, subscriber };","map":{"version":3,"names":["mailbox","queue","next","deliver","msg","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","push","shift","undefined","stop","receive","Promise","innerReceive","resolve","INIT","SUBSCRIBE","UNSUBSCRIBE","UPDATED","SNAPSHOT","EXIT","TERMINATE","root","self","_typeof","global","window","FCL_REGISTRY","pid","DEFAULT_TIMEOUT","_send","send","addr","tag","data","opts","arguments","length","reply","reject","expectReply","timeout","setTimeout","Error","concat","payload","to","from","error","console","kill","fromHandlers","handlers","_ref","ctx","letter","sent","abrupt","t0","_x","apply","spawn","fn","subs","Set","kvs","sendSelf","broadcast","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","err","e","f","subscribe","sub","add","unsubscribe","subscriberCount","size","hasSubs","put","key","get","fallback","_delete","update","keys","Object","all","where","pattern","reduce","acc","test","_objectSpread","_defineProperty","merge","forEach","fatalError","_iterator2","_step2","queueMicrotask","_callee2","_callee2$","_context2","subscriber","address","spawnFn","callback","_ref3","_callee3","_callee3$","_context3","_x2","snapshoter"],"sources":["C:\\Users\\gugan\\flow-hackverse\\node_modules\\@onflow\\util-actor\\src\\mailbox\\index.js","C:\\Users\\gugan\\flow-hackverse\\node_modules\\@onflow\\util-actor\\src\\index.js"],"sourcesContent":["export const mailbox = () => {\n  const queue = []\n  var next\n\n  return {\n    async deliver(msg) {\n      queue.push(msg)\n      if (next) {\n        next(queue.shift())\n        next = undefined\n      }\n    },\n\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift()\n        if (msg) return resolve(msg)\n        next = resolve\n      })\n    },\n  }\n}\n","import {mailbox as createMailbox} from \"./mailbox\"\nimport queueMicrotask from \"queue-microtask\"\n\nexport const INIT = \"INIT\"\nexport const SUBSCRIBE = \"SUBSCRIBE\"\nexport const UNSUBSCRIBE = \"UNSUBSCRIBE\"\nexport const UPDATED = \"UPDATED\"\nexport const SNAPSHOT = \"SNAPSHOT\"\nexport const EXIT = \"EXIT\"\nexport const TERMINATE = \"TERMINATE\"\n\nconst root =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global === \"object\" && global.global === global && global) ||\n  (typeof window === \"object\" && window.window === window && window)\n\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY\nvar pid = 0b0\n\nconst DEFAULT_TIMEOUT = 5000\nconst DEFAULT_TAG = \"---\"\nexport const send = (addr, tag, data, opts = {}) =>\n  new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT\n\n    if (expectReply && timeout) {\n      setTimeout(\n        () =>\n          reject(new Error(`Timeout: ${timeout}ms passed without a response.`)),\n        timeout\n      )\n    }\n\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject,\n    }\n\n    try {\n      root.FCL_REGISTRY[addr] &&\n        root.FCL_REGISTRY[addr].mailbox.deliver(payload)\n      if (!expectReply) reply(true)\n    } catch (error) {\n      console.error(\n        \"FCL.Actor -- Could Not Deliver Message\",\n        payload,\n        root.FCL_REGISTRY[addr],\n        error\n      )\n    }\n  })\n\nexport const kill = addr => {\n  delete root.FCL_REGISTRY[addr]\n}\n\nconst fromHandlers =\n  (handlers = {}) =>\n  async ctx => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx)\n    __loop: while (1) {\n      const letter = await ctx.receive()\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {})\n          }\n          break __loop\n        }\n        await handlers[letter.tag](ctx, letter, letter.data || {})\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error)\n      } finally {\n        continue __loop\n      }\n    }\n  }\n\nexport const spawn = (fn, addr = null) => {\n  if (addr == null) addr = ++pid\n  if (root.FCL_REGISTRY[addr] != null) return addr\n\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: createMailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null,\n  }\n\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: (to, tag, data, opts = {}) => {\n      opts.from = addr\n      return send(to, tag, data, opts)\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts)\n    },\n    broadcast: (tag, data, opts = {}) => {\n      opts.from = addr\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts)\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key]\n      return value == null ? fallback : value\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key]\n    },\n    update: (key, fn) => {\n      if (key != null)\n        root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key])\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs)\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key)\n          ? {...acc, [key]: root.FCL_REGISTRY[addr].kvs[key]}\n          : acc\n      }, {})\n    },\n    merge: (data = {}) => {\n      Object.keys(data).forEach(\n        key => (root.FCL_REGISTRY[addr].kvs[key] = data[key])\n      )\n    },\n    fatalError: error => {\n      root.FCL_REGISTRY[addr].error = error\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED)\n    },\n  }\n\n  if (typeof fn === \"object\") fn = fromHandlers(fn)\n\n  queueMicrotask(async () => {\n    await fn(ctx)\n    kill(addr)\n  })\n\n  return addr\n}\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nexport function subscriber(address, spawnFn, callback) {\n  spawnFn(address)\n  const EXIT = \"@EXIT\"\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE)\n    while (1) {\n      const letter = await ctx.receive()\n      const error = root.FCL_REGISTRY[address].error\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE)\n        return\n      }\n      if (error) {\n        callback(null, error)\n        ctx.send(address, UNSUBSCRIBE)\n        return\n      }\n\n      callback(letter.data, null)\n    }\n  })\n  return () => send(self, EXIT)\n}\n\n// Returns a promise that returns a result\n// A SNAPSHOT handler will need to be created to handle the snapshot event\n//\n//  [SNAPSHOT]: (ctx, letter) => {\n//    letter.reply(ctx.all())\n//  }\n//\nexport function snapshoter(address, spawnFn) {\n  spawnFn(address)\n  return send(address, SNAPSHOT, null, {expectReply: true, timeout: 0})\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}